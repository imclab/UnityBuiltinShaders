// ------------ Shadow helpers --------

// -------- Native shadow maps
#if defined SHADOWS_NATIVE

#define SHADOW_COORDS varying vec4 _ShadowCoord; varying float _ShadowFade;
uniform mat4 _World2Shadow;
uniform vec4 _LightShadowData;
#define TRANSFER_SHADOW _ShadowCoord = _World2Shadow * (_Object2World * gl_Vertex); _ShadowFade = (-(gl_ModelViewMatrix * gl_Vertex).z) * _LightShadowData.z + _LightShadowData.w;

#ifdef FRAGMENT
uniform sampler2D _ShadowMapTexture;

#if defined SHADOWS_PCF4
uniform vec4 _ShadowOffsets0;
uniform vec4 _ShadowOffsets1;
uniform vec4 _ShadowOffsets2;
uniform vec4 _ShadowOffsets3;
#endif

float unitySampleShadow( vec4 shadowCoord, float fade )
{
	#if defined SHADOWS_PCF4
	vec3 coord = shadowCoord.xyz / shadowCoord.w;
	
	vec4 shadowVals;
	shadowVals.x = texture2D( _ShadowMapTexture, coord.xy + _ShadowOffsets0.xy ).r;
	shadowVals.y = texture2D( _ShadowMapTexture, coord.xy + _ShadowOffsets1.xy ).r;
	shadowVals.z = texture2D( _ShadowMapTexture, coord.xy + _ShadowOffsets2.xy ).r;
	shadowVals.w = texture2D( _ShadowMapTexture, coord.xy + _ShadowOffsets3.xy ).r;
	bvec4 cm = lessThan(shadowVals, coord.zzzz);
	vec4 shadows;
	shadows.x = cm.x ? _LightShadowData.r : 1.0;
	shadows.y = cm.y ? _LightShadowData.r : 1.0;
	shadows.z = cm.z ? _LightShadowData.r : 1.0;
	shadows.w = cm.w ? _LightShadowData.r : 1.0;
	//shadows = lessThan(shadowVals, coord.zzzz) ? _LightShadowData.rrrr : vec4(1.0,1.0,1.0,1.0);
	
	/*
	vec3 coord = shadowCoord.xyz / shadowCoord.w;
	
	vec4 shadows;
	shadows.x = shadow2D( _ShadowMapTexture, coord + vec3(-offX,-offY,0) ).r;
	shadows.y = shadow2D( _ShadowMapTexture, coord + vec3(-offX, offY,0) ).r;
	shadows.z = shadow2D( _ShadowMapTexture, coord + vec3( offX,-offY,0) ).r;
	shadows.w = shadow2D( _ShadowMapTexture, coord + vec3( offX, offY,0) ).r;
	*/
	
	// average-4 PCF
	float shadow = dot( shadows, vec4(0.25,0.25,0.25,0.25) );
	
	#else
	
	float shadow = texture2DProj( _ShadowMapTexture, shadowCoord.xyw ).r < (shadowCoord.z / shadowCoord.w) ? _LightShadowData.r : 1.0;
	
	#endif
	
	return clamp( shadow + clamp(fade,0.0,1.0), 0.0, 1.0 );
}


#define SHADOW_ATTENUATION unitySampleShadow(_ShadowCoord,_ShadowFade)
#endif

#endif



// -------- Cube shadow maps
#if defined SHADOWS_CUBE

#define SHADOW_COORDS varying vec3 _ShadowCoord;
uniform vec4 _LightShadowData;
#define TRANSFER_SHADOW _ShadowCoord = (_Object2World * gl_Vertex).xyz - _LightPositionRange.xyz;

#ifdef FRAGMENT
uniform samplerCube _ShadowMapTexture;
float unityCubeShadow( vec3 vec )
{
	float mydist = length(vec) * _LightPositionRange.w;
	mydist *= 0.97; // bias
	vec4 packDist = textureCube( _ShadowMapTexture, vec );
	float dist = DecodeFloatRGBA( packDist );
	return dist < mydist ? _LightShadowData.r : 1.0;
}
#define SHADOW_ATTENUATION unityCubeShadow(_ShadowCoord)
#endif

#endif



// -------- Screen space shadow maps

#if defined SHADOWS_SCREEN

uniform vec4 _ShadowOffsets0;
uniform vec4 _ShadowOffsets1;
uniform vec4 _ShadowOffsets2;
uniform vec4 _ShadowOffsets3;

#define SHADOW_COORDS varying vec3 _ShadowCoord;
vec3 unityTransferShadow( vec4 hpos )
{
	mat4 mat = mat4(
		0.5, 0.0, 0.0, 0.5,
		0.0, 0.5 * _ProjectionParams.x, 0.0, 0.5,
		0.0, 0.0, 0.0, 1.0,
		0.0, 0.0, 0.0, 0.0
	);
	vec3 coord = (mat * hpos).xyz;
	coord.xy *= 0.5 / _ShadowOffsets3.xy;
	return coord;
}
#define TRANSFER_SHADOW _ShadowCoord = unityTransferShadow(gl_Position);

#ifdef FRAGMENT
uniform sampler2DRect _ShadowMapTexture;

float unitySampleShadow( vec3 shadowCoord )
{
	//float shadow = texture2DRECTproj( _ShadowMapTexture, shadowCoord ).r;
	return 1.0;
}
#define SHADOW_ATTENUATION unitySampleShadow(_ShadowCoord)
#endif

#endif


// -------- Shadows off
#if !defined SHADOWS_CUBE && !defined SHADOWS_NATIVE && !defined SHADOWS_SCREEN

#define SHADOW_COORDS
#define TRANSFER_SHADOW
#define SHADOW_ATTENUATION 1.0

#endif


// ------------ Light helpers --------


#ifdef POINT
#define LIGHTING_COORDS varying vec4 _LightCoord; SHADOW_COORDS
uniform sampler3D _LightTexture0;
uniform mat4 _SpotlightProjectionMatrix0;
#define TRANSFER_VERTEX_TO_FRAGMENT _LightCoord = _SpotlightProjectionMatrix0 * gl_Vertex; TRANSFER_SHADOW
// note: multiplying attenuation the other way around produces bugs on 10.4.8
#define LIGHT_ATTENUATION	(SHADOW_ATTENUATION * texture3D(_LightTexture0, _LightCoord.xyz).w)
#endif

#ifdef SPOT
#define LIGHTING_COORDS varying vec4 _LightCoord; SHADOW_COORDS
uniform sampler2D _LightTexture0;
uniform mat4 _SpotlightProjectionMatrix0;
uniform sampler2D _LightTextureB0;
uniform mat4 _SpotlightProjectionMatrixB0;
#define TRANSFER_VERTEX_TO_FRAGMENT _LightCoord.z = (_SpotlightProjectionMatrixB0*gl_Vertex).z; _LightCoord.xyw = (_SpotlightProjectionMatrix0*gl_Vertex).xyw; TRANSFER_SHADOW
#define LIGHT_ATTENUATION	(SHADOW_ATTENUATION * texture2DProj (_LightTexture0, _LightCoord.xyw).w * texture2D (_LightTextureB0, _LightCoord.zz).w)
#endif 

#ifdef DIRECTIONAL
#define LIGHTING_COORDS SHADOW_COORDS
#define TRANSFER_VERTEX_TO_FRAGMENT TRANSFER_SHADOW
#define LIGHT_ATTENUATION	(1.0 * SHADOW_ATTENUATION)
#endif

#ifdef POINT_NOATT
#define LIGHTING_COORDS SHADOW_COORDS
#define TRANSFER_VERTEX_TO_FRAGMENT TRANSFER_SHADOW
#define LIGHT_ATTENUATION	(1.0 * SHADOW_ATTENUATION)
#endif

#ifdef POINT_COOKIE
#define LIGHTING_COORDS varying vec3 _LightCoord; SHADOW_COORDS
uniform samplerCube _LightTexture0;
uniform mat4 _SpotlightProjectionMatrix0;
#define TRANSFER_VERTEX_TO_FRAGMENT _LightCoord = (_SpotlightProjectionMatrix0*gl_Vertex).xyz; TRANSFER_SHADOW
#define LIGHT_ATTENUATION	(textureCube(_LightTexture0, _LightCoord).w * SHADOW_ATTENUATION)
#endif


#ifdef DIRECTIONAL_COOKIE
#define LIGHTING_COORDS varying vec2 _LightCoord; SHADOW_COORDS
uniform sampler2D _LightTexture0;
uniform mat4 _SpotlightProjectionMatrix0;
#define TRANSFER_VERTEX_TO_FRAGMENT _LightCoord = (_SpotlightProjectionMatrix0*gl_Vertex).xy; TRANSFER_SHADOW
#define LIGHT_ATTENUATION	(texture2D(_LightTexture0, _LightCoord).w * SHADOW_ATTENUATION)
#endif

